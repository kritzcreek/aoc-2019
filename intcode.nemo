module intcode
exports (VM, init_vm, reset_vm, parse, run, add_input, get_output)

use option
use vec
use io

fn digit(i : I32) -> I32 {
  i - 48
}

fn is_comma(i : I32) -> Bool {
  i == 44
}

fn is_minus(i : I32) -> Bool {
  i == 45
}

fn parse(input : Bytes) -> Array[I32] {
  let len = bytes_len(input);
  let i = 0;
  let numbers = vec::new(0);
  let sign = 1;
  let current = 0;
  while i < len {
    let c = bytes_get(input, i);
    if is_minus(c) {
      set sign = -1;
    } else {
      if is_comma(c) {
        vec::push(numbers, current * sign);
        set current = 0;
        set sign = 1;
      } else {
        set current = current * 10 + digit(c);
      };
    };
    set i = i + 1;
  };
  vec::push(numbers, current);

  let result = array_new#[I32](0, numbers.len);
  set i = 0;
  while i < numbers.len {
    set result[i] = numbers.buf[i];
    set i = i + 1;
  };
  result
}

struct VM {
  code : Array[I32],
  pc : I32,
  input : vec::Vec[I32],
  output : vec::Vec[I32],
  running : Bool,
}

variant Mode {
  struct Immediate {},
  struct Position {},
}

fn print_mode(mode : Mode) {
  match mode {
    Mode::Immediate _ => { io::println_bytes("IMMEDIATE") },
    Mode::Position _ => { io::println_bytes("POSITION") },
  }
}

variant Instruction {
  struct Add { param1 : Mode, param2 : Mode },
  struct Mul { param1 : Mode, param2 : Mode },
  struct JumpIfTrue { param1 : Mode, param2 : Mode },
  struct JumpIfFalse { param1 : Mode, param2 : Mode },
  struct LessThan { param1 : Mode, param2 : Mode },
  struct Equals { param1 : Mode, param2 : Mode },
  struct Input { },
  struct Output { param1 : Mode },
  struct Halt { },
}

fn size(i : Instruction) -> I32 {
  match i {
    Instruction::Add _ => { 4 },
    Instruction::Mul _ => { 4 },
    Instruction::LessThan _ => { 4 },
    Instruction::Equals _ => { 4 },
    Instruction::JumpIfTrue _ => { 3 },
    Instruction::JumpIfFalse _ => { 3 },
    Instruction::Input _ => { 2 },
    Instruction::Output _ => { 2 },
    Instruction::Halt _ => { 1 },
  }
}

fn decode(i : I32) -> Instruction {
  let opcode = i % 100;
  if
    opcode == 1 || opcode == 2 || opcode == 5 ||
    opcode == 6 || opcode == 7 || opcode == 8 {
      let modes = i / 100;
      let param1 = if modes % 10 == 0 {
        Mode::Position {}
      } else {
        Mode::Immediate {}
      };
      let param2 = if (modes / 10) % 10 == 0 {
        Mode::Position {}
      } else {
        Mode::Immediate {}
      };
      if opcode == 1 {
        Instruction::Add { param1 = param1, param2 = param2 }
      } else {
        if opcode == 2 {
          Instruction::Mul { param1 = param1, param2 = param2 }
        } else {
          if opcode == 5 {
            Instruction::JumpIfTrue { param1 = param1, param2 = param2 }
          } else {
            if opcode == 6 {
              Instruction::JumpIfFalse { param1 = param1, param2 = param2 }
            } else {
              if opcode == 7 {
                Instruction::LessThan { param1 = param1, param2 = param2 }
              } else {
                if opcode == 8 {
                  Instruction::Equals { param1 = param1, param2 = param2 }
                } else {
                  Instruction::Halt {}
                }
              }
            }
          }
        };
      }
    } else {
      if opcode == 4 {
        let modes = i / 100;
        let param1 = if modes % 10 == 0 {
          Mode::Position {}
        } else {
          Mode::Immediate {}
        };
        Instruction::Output { param1 = param1 }
      } else {
        if opcode == 3 {
          Instruction::Input {}
        } else {
          if opcode == 99 {
            Instruction::Halt {}
          } else {
            Instruction::Halt {}
          }
        }
      }
    }
}

fn init_vm(code : Array[I32]) -> VM {
  let len = array_len#[I32](code);
  let copy = array_new#[I32](0, len);
  array_copy#[I32](copy, 0, code, 0, len);
  VM { code = copy, pc = 0, input = vec::new(0), output = vec::new(0), running = true }
}

fn reset_vm(vm : VM, code : Array[I32]) {
  array_copy#[I32](vm.code, 0, code, 0, array_len#[I32](code));
  set vm.pc = 0;
  set vm.running = true;
}

fn add_input(vm : VM, input : I32) {
  vec::push(vm.input, input)
}

fn get_output(vm : VM) -> I32 {
  match vec::pop(vm.output) {
    option::Option::Some s => { s.val },
  }
}

fn read(vm : VM, offset : I32, mode : Mode) -> I32 {
  match mode {
    Mode::Immediate _ => {
      vm.code[offset]
    },
    Mode::Position _ => {
      vm.code[vm.code[offset]]
    },
  }
}

fn write(vm : VM, offset : I32, value : I32)  {
  set vm.code[vm.code[offset]] = value;
}

fn execute(vm : VM, instruction : Instruction) -> Bool {
  match instruction {
    Instruction::Add i => {
      let x = read(vm, vm.pc + 1, i.param1);
      let y = read(vm, vm.pc + 2, i.param2);
      write(vm, vm.pc + 3, x + y)
    },
    Instruction::Mul i => {
      let x = read(vm, vm.pc + 1, i.param1);
      let y = read(vm, vm.pc + 2, i.param2);
      write(vm, vm.pc + 3, x * y)
    },
    Instruction::JumpIfTrue i => {
      let cond = read(vm, vm.pc + 1, i.param1);
      when cond != 0 {
        set vm.pc = read(vm, vm.pc + 2, i.param2);
        return true;
      }
    },
    Instruction::JumpIfFalse i => {
      let cond = read(vm, vm.pc + 1, i.param1);
      when cond == 0 {
        set vm.pc = read(vm, vm.pc + 2, i.param2);
        return true;
      }
    },
    Instruction::LessThan i => {
      let x = read(vm, vm.pc + 1, i.param1);
      let y = read(vm, vm.pc + 2, i.param2);
      write(vm, vm.pc + 3, if x < y { 1 } else { 0 })
    },
    Instruction::Equals i => {
      let x = read(vm, vm.pc + 1, i.param1);
      let y = read(vm, vm.pc + 2, i.param2);
      write(vm, vm.pc + 3, if x == y { 1 } else { 0 })
    },
    Instruction::Output i => {
      vec::push(vm.output, read(vm, vm.pc + 1, i.param1));
    },
    Instruction::Input _ => {
      match vec::pop(vm.input) {
        option::Option::Some s => {
          write(vm, vm.pc + 1, s.val);
        },
        option::Option::None _ => {
          return false
        }
      };
    },
    Instruction::Halt _ => {
      set vm.running = false
    }
  };
  set vm.pc = vm.pc + size(instruction);
  true
}

fn run(vm : VM) {
  while vm.running && vm.pc < array_len#[I32](vm.code) {
    let i = decode(vm.code[vm.pc]);
    when execute(vm, i) == false {
      return {};
    }
  }
}
